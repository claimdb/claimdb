"""This module has necessary DB-related operations (e.g., query execution, SQL query AST parsing etc.)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_dbops.ipynb.

# %% auto #0
__all__ = ['sqlite_execute_with_timeout', 'is_query_high_information']

# %% ../nbs/02_dbops.ipynb #0738f4af
from .configuration import *
import time
import sqlite3
from pathlib import Path

# %% ../nbs/02_dbops.ipynb #3475d76a
def sqlite_execute_with_timeout(database_path: Path, # Path to the Sqlite database
                                query:str,       # The Sqlite query to execute
                                timeout:int=30): # Timeout in seconds
    """ Runs a Sqlite query with a timeout. """
    start = time.time()

    def progress():
        # SQLite calls this regularly during execution
        if time.time() - start > timeout:
            return 1   # non-zero => interrupt query
        return 0

    conn = sqlite3.connect(database_path)

    conn.row_factory = sqlite3.Row
    conn.set_progress_handler(progress, 1000)

    try:
        cursor = conn.execute(query)
        rows = cursor.fetchall()
        return [dict(row) for row in rows]
    
    except sqlite3.OperationalError as e:
        if "interrupted" in str(e):
            return "timeout"
        return "error"
    
    except Exception as e:
        return "error"

    finally:
        if conn: conn.set_progress_handler(None, 0); conn.close()

# %% ../nbs/02_dbops.ipynb #97453430
import sqlglot

# %% ../nbs/02_dbops.ipynb #83bb39b2
def is_query_high_information(query  # The Sqlite query to analyze
                              ) -> bool:  # Whether the query is high-information 
    """ Returns whether a query has high-info characteristics."""
    tree = sqlglot.parse_one(query, dialect='sqlite')

    num_joins = len(list(tree.find_all(sqlglot.exp.Join)))
    aggregates = list(tree.find_all(sqlglot.exp.AggFunc))
    orderings = list(tree.find_all(sqlglot.exp.Order))

    if aggregates or orderings or num_joins >= 2:
        return True
    return False
